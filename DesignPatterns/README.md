## 设计模式 – 六大原则

### 1.开闭原则（Open Close Principle）

开闭原则的意思是： 对扩展开放，对修改关闭

在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果

简言之，是为了使程序的扩展性好，易于维护和升级

想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点

### 2. 里氏代换原则（Liskov Substitution Principle）
   里氏代换原则是面向对象设计的基本原则之一

里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现

LSP是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为

里氏代换原则是对开闭原则的补充

实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范

### 3. 依赖倒转原则（Dependence Inversion Principle）
   这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体

### 4. 接口隔离原则（Interface Segregation Principle）
   这个原则的意思是：使用多个隔离的接口，比使用单个接口要好

它还有另外一个意思是：降低类之间的耦合度

由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合

### 5. 迪米特法则，又称最少知道原则（Demeter Principle）
   最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

### 6. 合成复用原则（Composite Reuse Principle）
   合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承



## 1.创建型设计模式



创建型模式通常用于代替构造器的直接实例化。 它们使创建过程更具适应性和动态性。 特别是，它们可以为创建哪些对象，如何创建这些对象以及如何对其进行初始化提供很大的灵活性。

| 设计模式名称                 | 目的                                                         |
|------------------------| ------------------------------------------------------------ |
| Factory Method(工厂)     | 当涉及复杂的对象创建步骤时，工厂设计模式最合适。 为了确保这些步骤是集中的，并且不暴露于组成类。 |
| Abstract Factory（抽象工厂） | 每当我们需要对使用工厂模式创建的一组工厂进行另一个抽象级别时，就会使用抽象工厂模式。 |
| Builder(构建器)           | 构建器设计模式是构建复杂对象的另一种方法，仅当我们希望使用相同的对象构建过程构建不同类型的不可变对象时，才应使用构建器设计模式。 |
| Prototype（原型）          | 原型设计模式用于应用需要创建大量类的实例的情况，这些实例的状态几乎相同或相差很小。 |
| Singleton（单例）          | 单例使应用每个 JVM 具有一个类的一个实例。                    |



## 2.结构型设计模式



结构型设计模式向我们展示了如何以灵活和可扩展的方式将系统的不同部分粘合在一起。 这些模式帮助我们确保当其中一部分发生更改时，整个应用结构都不需要更改。

| 设计模式名称 | 目的                                                         |
|--------| ------------------------------------------------------------ |
| Adapter（适配器） | 适配器将类的接口转换为客户端期望的另一个接口。 它可以让类因接口不兼容而无法一起工作。 |
| Bridge（桥接） | 桥接器设计模式用于将一个类分解为两部分 - *抽象*和*实现* – 以便将来可以相互进化而不会相互影响。 它增加了类抽象与其实现之间的松散耦合。 |
| Composite(组合) | 将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。 |
| Decorator(装饰) | 装饰器设计模式用于向类的特定实例添加其他功能或行为，而不会修改同一类的其他实例。 |
| Facade（外观） | 外观设计模式为子系统中的一组接口提供了统一的接口。 外观定义了一个更高级别的接口，使子系统更易于使用。 |
| Flyweight（享元） | 享元设计模式允许使用对象共享，以有效支持大量细粒度的对象。 享元是一个共享对象，可以同时在多个上下文中使用。 享元在每种情况下都充当独立对象。 |
| Proxy（代理） | 在代理设计模式中，代理对象为另一个对象提供代理或占位符，以控制对其的访问。 代理大量用于实现与延迟加载相关的用例，在这种情况下，我们直到真正需要时才创建完整的对象。 |



## 3.行为型设计模式



行为型模式抽象了我们要对采取该操作的对象或类采取的操作。 通过更改对象或类，我们可以更改所使用的算法，受影响的对象或行为，同时仍为客户端类保留相同的基本接口。

| 设计模式名称                      | 目的                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| Chain of Responsibility（职责链） | 责任链设计模式通过以链的形式将接收对象链接在一起，为多个对象提供了处理请求的机会。 |
| Command（命令）                   | 命令设计模式对于将业务逻辑抽象为离散的动作（我们称为命令）很有用。 这些命令对象有助于两个类之间的松散耦合，其中一个类（调用者）应调用另一类（接收者）上的方法来执行业务操作。 |
| Interpreter（解析器）             | 解释器模式指定如何以编程方式求值一种语言的句子。 它有助于为一种简单的语言建立语法，以便可以解释该语言中的句子。 |
| Iterator（迭代器）                | 迭代器模式提供了一种在不暴露其基础表示的情况下顺序访问聚合对象的元素的方法。 |
| Mediator（中介）                  | 中介者模式定义了一个对象，该对象封装了一组对象之间的交互方式。 中介者通过防止对象之间显式地相互引用来促进松散耦合，并且它使我们可以独立地更改其交互。 |
| Memento（备忘录）                 | 备忘录模式用于将对象的状态恢复到先前的状态。 也称为快照模式。 |
| Observer（观察者）                | 观察者模式定义了对象之间的一对多依赖关系，因此当一个对象改变状态时，其所有依赖关系都会得到通知并自动更新。 它也称为发布 - 订阅模式。 |
| State（状态）                     | 在状态模式下，对象可以在其内部状态更改时更改其行为。 该对象似乎将更改其类。 每个对象的可能状态应有一个单独的具体类。 |
| Strategy（策略）                  | 当我们在运行时从算法的多个其他实现中选择特定的算法或任务实现时，将使用策略模式。 |
| Template Method（模板方法）       | 模板方法模式定义了执行多步算法的顺序步骤，并且还可以选择提供默认实现（基于需求）。 |
| Visitor（访问者）                 | 当我们希望对象的层次结构修改其行为但不修改其源代码时，将使用访问者模式。 |

 

















